syntax = "proto3";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

import "tetra3.proto";

package cedar;

// In cedar_flutter/lib:
// run: protoc --dart_out=grpc:. --proto_path=../../src/proto ../../src/proto/cedar.proto

// General note: in the Cedar gRPC protocol, the client is a user interface
// realized as a web app or a mobile app. The client interacts with the
// server via gRPC, using the messages and RPCs defined in this proto file.
//
// The server runs independently of the client. In particular, image
// acquisitions, star detection, plate solving, and updates of SkySafari occur
// in the server even if no user interface app is connected. A client can obtain
// FrameResults at a rate equal to or slower than the rate at which the server
// is producing results.
//
// Note also that multiple clients can be connected to the same server, in which
// case each client can independenly obtain its own sequence of FrameResults
// without affecting the FrameResults seen by other clients (in other words, if
// client A obtains a FrameResult X, it is not "consumed", so client B can
// obtain the same FrameResult X). However, if any client updates the operating
// mode or settings of the server, the result of this will be visible to all
// clients.
//
// Finally, note Cedar's integration with SkySafari is a protocol separate from
// the gRPC protocol defined in this proto file. Similarly, Cedar's gRPC
// integration with Tetra3 is described in a separate proto file.

message FixedSettings {
  // Focal length of lens, in millimeters. If provided, this is used as a hint
  // during camera/sky calibration. Note that the camera sensor's parameters
  // (resolution and size) are obtained by the server from the camera interface.
  optional float lens_fl_mm = 1;

  // Lat/long of observer location, in degrees.
  optional float latitude = 2;
  optional float longitude = 3;

  // The current time on the client. The server's current time is updated to
  // match.
  optional google.protobuf.Timestamp client_time = 4;

  // A name for the current observing session. If not supplied, one is generated
  // from the current time and the supplied latitude/longitude (converted to a
  // nearby location name).

  // The session name is used when storing calibration data, boresight offset,
  // when logging dwell positions, and when logging debugging captures (the
  // latter should go elsewhere?). A processed catalog can also be associated
  // with the session.
  optional string session_name = 5;
}

message OperationSettings {
  // TODO: Camera number.

  // The camera's gain, [0..100]. Default is determined by camera/sky calibration,
  // or 100 if no calibration has been done.
  optional int32 camera_gain = 2;

  // The camera's offset [0..20]. Default is determined by camera/sky calibration,
  // or 0 if no calibration has been done.
  optional int32 camera_offset = 3;

  // Defaults to OPERATING_MODE_SETUP.
  optional OperatingMode operating_mode = 4;

  // The camera exposure integration time. Zero selects automatic exposure.
  // Default is zero (auto).
  optional google.protobuf.Duration exposure_time = 5;

  // The S/N factor used to determine if a background-subtracted pixel is bright
  // enough relative to the noise measure to be considered part of a star. Zero
  // selects automatic determination based on camera/sky calibration; if no
  // calibration has been done 8 is used.
  optional float detection_sigma = 6;

  // StarGate clumps adjacent bright pixels to form a single star candidate. The
  // `detection_max_size` argument governs how large a clump can be before it is
  // rejected. Note that making `max_size` small can eliminate very bright stars
  // that "bleed" to many surrounding pixels.
  // Default is 5.
  optional int32 detection_max_size = 12;

  // The desired time interval at which Cedar should replace its current frame
  // result. Default is zero, meaning go as fast as possible.
  optional google.protobuf.Duration update_interval = 7;

  // In OPERATING_MODE_OPERATE, when Cedar detects that the camera is dwelling
  // (motionless) for more than some number of seconds, `dwell_update_interval`
  // is used instead of `update_interval`. Default is 1sec.
  optional google.protobuf.Duration dwell_update_interval = 8;

  // If true, when Cedar detects that the camera is dwelling (motionless) for
  // more than some number of seconds, the RA/DEC is logged. Note that if the
  // RA/DEC are changing during dwelling due to sidereal motion (non-tracked
  // mount) or polar misalighment (tracked equatorial mount), only the RA/DEC
  // at the onset of dwelling is logged.
  optional bool log_dwelled_positions = 10;
}

enum OperatingMode {
  OPERATING_MODE_UNSPECIFIED = 0;

  // Mode supporting establishment of camera focus and boresight alignment of
  // camera and telescope:
  // * Exposure metered based on brightest point in central region.
  OPERATING_MODE_SETUP = 1;

  // TODO: sky/camera calibration is a top-level operating mode?

  // Main operating mode. Continually updated RA/DEC sent to SkySafari.
  // Detection of tracking mount and accumulation of polar alignment advice
  // during dwells.
  // * Exposure metered based on camera/sky calibration carried out in setup
  //   mode.
  OPERATING_MODE_OPERATE = 2;
}

message FrameRequest {
  // This is the frame_id of the previous FrameResult obtained by the requesting
  // client. If provided, GetFrame() will block until this is no longer the
  // server's current FrameResult. If omitted, GetFrame() will return the
  // server's current FrameResult.
  optional int32 prev_frame_id = 1;

  // Controls whether and how the camera's image is returned with the
  // FrameResult.
  ImageMode main_image_mode = 2;
}

// Used by FrameRequest to control inclusion of the main image in the
// FrameResult.
enum ImageMode {
  // Full resolution image will be returned.
  IMAGE_MODE_DEFAULT = 0;

  // The image is omitted.
  IMAGE_MODE_OMIT = 1;

  // 2x2 binned image will be returned.
  IMAGE_MODE_BINNED = 2;
}

// Next tag: 22.
message FrameResult {
  // Identifies this FrameResult. A client can include this in its next
  // FrameRequest to block until a new FrameResult is available.
  int32 frame_id = 1;

  // The Cedar settings in effect for this frame.
  optional OperationSettings operation_settings = 2;

  // TODO: CalibrationData in effect for this frame.

  // Information returned regardless of `operating_mode`. Note that these fields
  // are ommitted while a camera/sky calibration is underway (see below).

  // The image from which information in this FrameResult is derived. Can be
  // omitted or binned according to the FrameRequest.
  optional Image image = 3;

  // The star candidates detected by StarGate; ordered by highest
  // brightness first.
  repeated StarCentroid star_candidates = 4;

  // The number of hot pixels detected by StarGate.
  int32 hot_pixel_count = 6;

  // The camera exposure integration time.
  google.protobuf.Duration exposure_time = 7;

  // The time interval at which Cedar replaces its current frame result. This is
  // a moving average over recent results. Note that this is independent of the
  // rate of client FrameRequests.
  google.protobuf.Duration result_update_interval = 8;

  // The time at which `image` was captured.
  google.protobuf.Timestamp capture_time = 9;

  // The camera temperature when `image` was captured.
  float camera_temperature_celsius = 10;

  // The position in image coordinates of the captured boresight. Absent if
  // no boresight has been captured. See ActionRequest.capture_boresight.
  optional ImageCoord boresight_position = 21;

  // Information returned when `operating_mode` is OPERATING_MODE_SETUP. Note
  // that these fields are ommitted while a camera/sky calibration is underway
  // (see below).

  // Identifies the center region used for brightest-star detection for focusing
  // support.
  optional Rectangle center_region = 11;

  // The estimated position of the brightest point in `center_region`. In full
  // resolution image coordinates.
  optional ImageCoord center_peak_position = 12;

  // A small full resolution crop of `image` centered at `center_peak_position`.
  optional Image center_peak_image = 13;

  // In OPERATING_MODE_SETUP, Cedar can be instructed to perform a camera/sky
  // calibration. Most of the above fields are omitted while such a calibration
  // is underway, and the following fields are present.

  // Non-zero while a camera/sky calibration is underway.
  CalibrationPhase calibration_phase = 15;

  // Estimated completion fraction [0..1) of the calibration.
  optional float calibration_progress = 16;

  // TODO: calibration operation result? E.g. none performed; no stars detected;
  // too much movement during capture; other inconsistencies.

  // Information returned when `operating_mode` is OPERATING_MODE_OPERATE.

  // The current plate solution.
  optional tetra3_server.SolveResult plate_solution = 17;

  // Detected camera motion.
  optional MotionType camera_motion = 18;

  // Estimated rate of RA boresight movement eastward (positive) or westward
  // (negative). Unit is degrees per second (full circle in RA is 24h). Omitted
  // if `camera_motion` is MOTION_TYPE_UNKNOWN.
  optional float ra_rate = 19;

  // Estimated rate of DEC boresight movement northward (positive) or southward
  // (negative). Unit is degrees per second. Omitted if `camera_motion` is
  // MOTION_TYPE_UNKNOWN.
  optional float dec_rate = 20;

  // advice
  // * polar alignment (operation mode only)

  // alerts
  // * prolonged loss of stars; need setup mode?
}

message Image {
  // Whether the image is binned or full resolution. Values:
  // 1 (or omitted): full resolution
  // 2: 2x2 binning.
  int32 binning_factor = 1;

  // Specifies what part of the camera sensor this Image corresponds to, in full
  // resolution units. If binning_factor is 2, the `image_data` dimensions are
  // rectangle.width/2, rectangle.height/2 (floored).
  Rectangle rectangle = 2;

  // Must be a recognized file format, e.g. BMP grayscale 8 bits per pixel.
  bytes image_data = 3;
}

// Describes the position/size of an Image within the camera's sensor.
message Rectangle {
  int32 origin_x = 1;
  int32 origin_y = 2;
  int32 width = 3;
  int32 height = 4;
}

// Summarizes a star-like spot found by the StarGate algorithm.
message StarCentroid {
  // Location of star centroid in full resolution image coordinates.
  ImageCoord centroid_position = 1;

  // Sum of the uint8 pixel values of the star's region. The estimated
  // background is subtracted.
  float brightness = 4;

  // Count of saturated pixel values.
  int32 num_saturated = 6;
}

message ImageCoord {
  // A location in full resolution image coordinates. (0.5, 0.5) corresponds to
  // the center of the image's upper left pixel.
  float x = 1;
  float y = 2;
}

// Identify calibration activities that require more than a trivial amount of
// time to complete.
enum CalibrationPhase {
  // Calibration not underway.
  CALIBRATION_PHASE_NONE = 0;

  // Capturing a set of images over a range of exposure times, gain values, and
  // offset values.
  CALIBRATION_PHASE_EXPOSURE_SWEEP = 1;

  // Analyzing the captured image set to determine:
  // * Minimum offset value that avoids crushing too many pixels to 0 value.
  // * Optimum gain value for best signal to noise.
  // * At optimum gain value, minimum and maximum exposure integration times for
  //   obtaining good star counts and avoiding too many overexposed stars.
  CALIBRATION_PHASE_ANALYZE_EXPOSURE = 2;

  // Obtain initial plate solution with loose constraints to obtain the true
  // field of view and lens distortion.
  CALIBRATION_PHASE_ANALYZE_FIELD_OF_VIEW = 3;

  // Determining the StarGate "sigma" levels to use to maximize true star
  // detections and minimize false star detections, using catalogue as ground
  // (sky) truth.
  CALIBRATION_PHASE_ANALYZE_STAR_THRESHOLD = 4;
}

message CalibrationData {
  // Omitted if a sky/camera calibration has not been done.
  optional google.protobuf.Timestamp calibration_start_time = 1;
  optional google.protobuf.Timestamp calibration_end_time = 2;
  optional float calibration_temperature_celsius = 3;

  // If no calibration has been done, these will have reasonable default values.
  optional google.protobuf.Duration min_exposure_time = 4;
  optional google.protobuf.Duration max_exposure_time = 5;

  // The camera gain value [0..100] at which S/N is maximized.
  // Omitted if a sky/camera calibration has not been done.
  optional int32 optimal_camera_gain = 6;

  // The camera offset value [0..20] found to be needed to avoid black crush.
  // Omitted if a sky/camera calibration has not been done.
  optional int32 camera_offset = 7;

  // The optimal S/N factor used to determine if a background-subtracted pixel
  // is bright enough relative to the noise measure to be considered part of a
  // star.
  // Omitted if a sky/camera calibration has not been done.
  optional float detection_sigma = 8;

  // Omitted if a sky/camera calibration has not been done.
  optional float min_exposure_limiting_magnitude = 10;
  optional float max_exposure_limiting_magnitude = 11;

  // If sky/camera calibration has not been done, this will be the FixedSettings
  // `lens_fl_mm` value.
  optional float lens_fl_mm = 12;

  // Omitted if a sky/camera calibration has not been done.
  optional float lens_distortion = 13;

  // The angular size of a pixel, in radians. This is for the field center, as
  // the "pinhole" projection of sky angles onto a planar detector causes the
  // pixel/angle scale to vary as you move away from the center.
  // If sky/camera calibration has not been done, this will be derived from the
  // FixedSettings `lens_fl_mm` value and the camera's sensor size and pixel
  // count.
  optional float pixel_angular_size = 14;

  // The angular size (radians) of the camera's width projected onto the sky.
  // If sky/camera calibration has not been done, this will be derived from the
  // FixedSettings `lens_fl_mm` value and the camera's sensor size and pixel
  // count.
  optional float fov_horizontal = 15;
}

enum MotionType {
  // Motion unknown. This is possible either when there are no star detections
  // and thus no plate solutions, and there is no IMU to sense motion independent
  // of plate solutions.
  MOTION_TYPE_UNKNOWN = 0;

  // Recent plate solutions are consistent with signficant movement of the
  // boresight in RA/DEC.
  MOTION_TYPE_MOVING = 1;

  // Recent plate solutions are consistent with sidereal movement of the
  // boresight in RA/DEC, such as would be seen when the camera's orientation is
  // fixed relative to the earth.
  MOTION_TYPE_DWELL_UNTRACKED = 2;

  // Recent plate solutions are consistent with little to no movement of the
  // boresight in RA/DEC, such as would be seen when the camera is mounted on
  // a motorized equatorial mount.
  MOTION_TYPE_DWELL_TRACKED = 3;
}

message PolarAlignmentAdvice {
  // Estimate of alt/az error of polar axis. Not available for non-tracking
  // mount (auto-detected).

  // Suggestion of sky region to dwell at for updated solution.
}

message ActionRequest {
  // Capture boresight offset (focus mode only) based on current location of
  // brightest peak in central region. Context:
  // 1. Cedar is in focus mode.
  // 2. User focuses on bright star.
  // 3. User centers the same star in the telescope's field of view.
  // 4. User adjusts aim of the Cedar camera to have the bright star near the
  //    center of the image.
  // 5. User invokes the capture_boresight function.
  // At this point, the captured boresight position will be returned in each
  // FrameResult's `boresight_position` field, and will cause a single
  // `target_coords` entry to be included with each FrameResult
  // `plate_solution`.
  optional bool capture_boresight = 1;

  // Drops the captured boresight, if any. The FrameResult `boresight_position`
  // field is omitted, and the `plate_solution` field `target_coords` will be
  // empty.
  optional bool delete_boresight = 2;

  // Calibrate camera/sky (focus mode only). Pre-empts focus mode operation until
  // completed or canceled.

  // Cancel camera/sky calibration.

  // Optimize catalogue (requires camera/sky calibration). Uses calibration's limiting
  // magnitude (at calibration's determined maximum exposure) to trim the catalog.
  // Resulting catalog is associated with the session.
  // What else?
  // Proceeds in background.

  // Save image.
}

message ServerInformationRequest {
  // Empty.
}

message ServerInformationResult {
  // Cedar version.

  // Tetra3 version.

  // Star catalog information.

  // Processor info.
  // * model: RPi or other board model
  // * OS version, etc.
  // * Ram
  // * Free disk space

  // Network info (hosted network, or access point?)

  // Current time (UTC) on Cedar server.

  // ordered list of detected cameras; for each:
  // * Camera make/model
  // * Resolution

  // Status of SkySafari integration; SkySafari version.
}

message EmptyMessage {}

service Cedar {
  // Returns information about the Cedar server.
  // rpc GetServerInformation(ServerInformationRequest) returns (ServerInformationResult);

  // Changes zero or more of Cedar's "fixed" settings. If a field is omitted
  // from the supplied FixedSettings, that setting is not updated. Returns the
  // FixedSettings after any updates have been applied. To get the current
  // settings without making any changes, pass an empty FixedSettings request.
  rpc UpdateFixedSettings(FixedSettings) returns (FixedSettings);

  // Changes zero or more of Cedar's operation settings. If a field is omitted
  // from the supplied OperationSettings, that setting is not updated. Returns
  // the OperationSettings after any updates have been applied. To get the
  // current settings without making any changes, pass an empty
  // OperationSettings request.
  rpc UpdateOperationSettings(OperationSettings) returns (OperationSettings);

  // Obtains the most recent Cedar computation result. Blocks if necessary to
  // wait for a new result (see FrameRequest's `prev_frame_id` field).
  rpc GetFrame(FrameRequest) returns (FrameResult);

  // Streaming variant of GetFrame().
  // TODO: figure out how this RPC knows when to end. In principle it could
  // stream back FrameResults on an open-ended basis. Client cancels?
  rpc GetFrames(FrameRequest) returns (stream FrameResult);

  // Performs the requested action(s).
  rpc InitiateAction(ActionRequest) returns (EmptyMessage);

  // TODO: list/get available sky/camera calibration data (by name). Calibration
  // names are based on the session name, suffixed by an integer (in case
  // multiple calibrations are performed during a session).

  // TODO: use the calibration data for a given calibration name.
}
